import { AES, enc, mode, pad } from 'crypto-js';

const Pbkdf2KeySize = 48;

export function Pbkdf2Key(password: Uint8Array, salt: Uint8Array, iter: number): Uint8Array {
    const derivedKey = pbkdf2Key(password, salt, iter, Pbkdf2KeySize);
    return new Uint8Array(derivedKey);
}

export function EncryptCBCPbkdf2Key(plantText: Uint8Array, pbkdf2Key: Uint8Array): Uint8Array {
    if (pbkdf2Key.length !== Pbkdf2KeySize) {
        throw new Error(`Crypted Key length error(${pbkdf2Key.length}), Crypted Key length should be ${Pbkdf2KeySize}`);
    }
    const key = pbkdf2Key.slice(0, Pbkdf2KeySize - 16);
    const iv = pbkdf2Key.slice(Pbkdf2KeySize - 16);
    return EncryptCBC(plantText, key, iv);
}

export function DecryptCBCPbkdf2Key(plantText: Uint8Array, pbkdf2Key: Uint8Array): Uint8Array {
    if (pbkdf2Key.length !== Pbkdf2KeySize) {
        throw new Error(`Crypted Key length error(${pbkdf2Key.length}), Crypted Key length should be ${Pbkdf2KeySize}`);
    }
    const key = pbkdf2Key.slice(0, Pbkdf2KeySize - 16);
    const iv = pbkdf2Key.slice(Pbkdf2KeySize - 16);
    return DecryptCBC(plantText, key, iv);
}

function pbkdf2Key(password: Uint8Array, salt: Uint8Array, iter: number, keySize: number): string {
    const passwordHex = enc.Hex.parse(bytesToHex(password));
    const saltHex = enc.Hex.parse(bytesToHex(salt));
    const key = enc.Hex.stringify(AES.decrypt({ ciphertext: saltHex }, passwordHex, { mode: mode.ECB, padding: pad.NoPadding }));
    return key.substr(0, keySize * 2); // Convert to bytes
}

function EncryptCBC(plantText: Uint8Array, key: Uint8Array, iv: Uint8Array): Uint8Array {
    if (iv.length !== 16) {
        throw new Error(`IV length error(${iv.length}), aes cbc IV length should be 16`);
    }
    const keyHex = enc.Hex.parse(bytesToHex(key));
    const ivHex = enc.Hex.parse(bytesToHex(iv));
    const plantTextHex = enc.Hex.parse(bytesToHex(plantText));
    const encrypted = AES.encrypt({ ciphertext: plantTextHex }, keyHex, { iv: ivHex, mode: mode.CBC, padding: pad.Pkcs7 });
    const ciphertext = enc.Hex.parse(encrypted.ciphertext.toString());
    return hexToBytes(enc.Hex.stringify(ciphertext));
}

function DecryptCBC(ciphertext: Uint8Array, key: Uint8Array, iv: Uint8Array): Uint8Array {
    if (iv.length !== 16) {
        throw new Error(`IV length error(${iv.length}), aes cbc IV length should be 16`);
    }
    const keyHex = enc.Hex.parse(bytesToHex(key));
    const ivHex = enc.Hex.parse(bytesToHex(iv));
    const ciphertextHex = enc.Hex.parse(bytesToHex(ciphertext));
    const decrypted = AES.decrypt({ ciphertext: ciphertextHex }, keyHex, { iv: ivHex, mode: mode.CBC, padding: pad.Pkcs7 });
    const plantText = enc.Hex.parse(decrypted.toString());
    return hexToBytes(enc.Hex.stringify(plantText));
}

function bytesToHex(bytes: Uint8Array): string {
    return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');
}

function hexToBytes(hex: string): Uint8Array {
    const bytes = [];
    for (let i = 0; i < hex.length; i += 2) {
        bytes.push(parseInt(hex.substr(i, 2), 16));
    }
    return new Uint8Array(bytes);
}